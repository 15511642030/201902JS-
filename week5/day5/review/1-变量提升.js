/*
* 变量提升：
*   1. 作用域开辟后，js代码执行之前，对带var和function的进行预解析；带var的是只声明不定义，而带function的既声明又定义；（声明：告诉浏览器有这个一个变量，定义是给这个变量赋值）；
*   2. 变量提升的细节问题：
*     2.1 变量提升不理会条件
*     2.2 变量提升只发生在当前作用域
*     2.3 变量提升只提升等号左边的
*     2.4 return右边的代码不会进行变量提升
*     2.5 return 下面的代码虽然不会执行但是仍然会进行变量提升
*     2.6 多次声明同一个变量，只声明一次，但是赋值的时候后面的会覆盖前面的。(需要特殊注意的是变量名和函数名同名的时候）
*     2.7 匿名函数没有变量提升
*   3. 带var不带var的区别：
*     3.1 带var会进行变量提升，如果是在全局声明还会给window增加一个全局属性；
*     3.2 不带var不会进行变量提升，如果赋值就会给window增加一个属性；
*     3.3 如果带var，在声明之前使用不会报错，如果不带var在赋值之前使用就会报错；
*     3.4 delete 不能删除在全局作用域中声明的变量（是因为浏览器机制把全局变量映射到上面了）
*    4. var let const的区别；var 是variable的前三个字母
*     4.1 let和const是es6新增的关键字，let用来声明变量，const用来声明常量。
*     4.2 var会变量提升，let和const不会进行变量提升；这就导致如果你是用let或者const声明变量或者常量，必须保证在使用之前声明（const还需要声明时完成定义）；
*     4.3 var声明变量可以重复声明，而let或const不可以；如果重复声明会报错：Uncaught SyntaxError：Identifier xxx has already been declared【未能捕获的语法错误：标识符 xxx 已经被声明过】
*     4.4 let 和 const会在代码块中形成块级作用域，而var不会；（for循环如果用var声明标识符，就会导致标识符代表是循环终止之后的值，因为var把这个标识符声明在全局作用域中了）
*     4.5 let和const在全局中声明的变量不会向window上增加同名属性。
*     4.6 暂时性死区得以解决，typeof不再是最安全的运算符
*     4.7 let声明的变量可以修改，const声明的基本数据类型不能修改，引用数据可以修改堆内存中的东西，但是不能修改这个堆内存地址；
*
*   5. 堆栈内存释放：
*     5.1 堆内存是存储引用数据类型值的，栈内存是js代码执行的环境、存储基本数据类型值；
*     5.2 堆内存释放：将变量指向null，等到浏览器主线程空闲的时候就会进行垃圾回收，这块堆内存就被释放；（IE浏览器采用引用计数，等到计数为0的时候就回收这块堆内存）
*     5.3 栈内存：函数执行就会新开栈内存，一般情况下函数执行完，栈内存随即销毁；但是当函数中的某一部分被外界占用，此时这个栈内存不能被销毁；
*
*   6. 作用域链：是变量查找，当我们使用一个变量的时候先看当前作用域中是否有这个变量，如果有就使用当前作用域中的变量，如果没有就向上级作用域查找，一直找到window位置，如果还没有就会报错：Uncaught ReferenceError: b is not defined 【未能捕获的引用错误】：b 没有定义
*   7. 函数执行执行形成的作用域就是闭包；保护私有变量不受外界干扰；
*   function () {
*   // 这个只是闭包一种情况而已
*     return function () {}
*   }
*/
